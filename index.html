<!-- 登录模态框（修复后） -->
<div id="loginModal" class="fixed inset-0 bg-black/50 z-50 flex items-center justify-center opacity-0 pointer-events-none transition-opacity duration-300">
    <div class="bg-white rounded-xl shadow-xl w-full max-w-md mx-4 transform scale-95 opacity-0 transition-all duration-300" id="modalContent">
        <div class="p-6 md:p-8">
            <div class="flex justify-between items-center mb-6">
                <h3 class="text-xl font-bold">登录</h3>
                <button id="closeLoginModal" class="text-gray-400 hover:text-gray-600 focus:outline-none">
                    <i class="fa fa-times text-xl"></i>
                </button>
            </div>
            
            <form id="loginForm">
                <!-- 表单内容保持不变 -->
                <div class="mb-6">
                    <label for="loginPhone" class="block text-sm font-medium mb-2">手机号</label>
                    <input type="tel" id="loginPhone" class="w-full px-4 py-3 rounded-lg border border-gray-300" placeholder="请输入手机号" required>
                </div>
                <div class="mb-6">
                    <label for="loginPassword" class="block text-sm font-medium mb-2">密码</label>
                    <input type="password" id="loginPassword" class="w-full px-4 py-3 rounded-lg border border-gray-300" placeholder="请输入密码" required>
                </div>
                <button type="submit" class="w-full bg-primary text-white py-3 rounded-lg">登录</button>
            </form>
        </div>
    </div>
</div>

<script>
// 修复登录模态框显示逻辑
document.addEventListener('DOMContentLoaded', function() {
    // 强制重新绑定登录按钮事件（避免事件丢失）
    const loginButtons = [
        document.getElementById('loginBtn'),
        document.getElementById('mobileLoginBtn'),
        document.getElementById('submitLoginBtn')
    ];
    
    // 确保按钮存在再绑定事件
    loginButtons.forEach(btn => {
        if (btn) {
            // 先移除旧事件，避免重复绑定
            btn.removeEventListener('click', showLoginModal);
            btn.addEventListener('click', showLoginModal);
        }
    });

    // 修复模态框显示函数（确保动画完整执行）
    function showLoginModal() {
        const modal = document.getElementById('loginModal');
        const modalContent = document.getElementById('modalContent');
        
        if (!modal || !modalContent) {
            console.error('登录模态框元素未找到');
            return; // 避免后续错误
        }
        
        // 强制重置状态（解决动画残留问题）
        modalContent.classList.remove('scale-100', 'opacity-100');
        modalContent.classList.add('scale-95', 'opacity-0');
        
        // 先显示背景，再执行动画（解决浏览器渲染顺序问题）
        modal.classList.remove('opacity-0', 'pointer-events-none');
        
        // 延迟触发动画，确保浏览器正确渲染
        setTimeout(() => {
            modalContent.classList.remove('scale-95', 'opacity-0');
            modalContent.classList.add('scale-100', 'opacity-100');
        }, 50); // 增加延迟，确保过渡生效
    }

    // 修复关闭按钮事件
    const closeBtn = document.getElementById('closeLoginModal');
    if (closeBtn) {
        closeBtn.addEventListener('click', function() {
            const modal = document.getElementById('loginModal');
            const modalContent = document.getElementById('modalContent');
            
            if (modal && modalContent) {
                // 先执行缩小动画
                modalContent.classList.remove('scale-100', 'opacity-100');
                modalContent.classList.add('scale-95', 'opacity-0');
                
                // 动画结束后隐藏背景
                setTimeout(() => {
                    modal.classList.add('opacity-0', 'pointer-events-none');
                }, 300);
            }
        });
    }

    // 防止事件冒泡导致的意外关闭
    document.getElementById('modalContent')?.addEventListener('click', function(e) {
        e.stopPropagation();
    });

    // 点击模态框外部关闭（增强容错）
    document.getElementById('loginModal')?.addEventListener('click', function(e) {
        if (e.target === this) {
            closeBtn?.click();
        }
    });
});
</script>
    
